# -*- coding: utf-8 -*-
"""Beta_Lstm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LX4xBbMmEnRGfgmtEwWS4LmpA9OUNpT_
"""

!pip install bayesian-optimization

!pip install pmdarima

import numpy as np
import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, MaxPooling1D, LSTM, Dense, Dropout
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.optimizers import Adam
import matplotlib.pyplot as plt
from bayes_opt import BayesianOptimization
from statsmodels.tsa.arima.model import ARIMA
import pmdarima as pm


# Function to calculate technical indicators
def calculate_technical_indicators(df, indicators, periods):
    if 'SMA' in indicators:
        df['SMA'] = df['Close'].rolling(window=periods['SMA']).mean()
    if 'EMA' in indicators:
        df['EMA'] = df['Close'].ewm(span=periods['EMA'], adjust=False).mean()
    if 'RSI' in indicators:
        df['RSI'] = compute_rsi(df['Close'], periods['RSI'])
    if 'MACD' in indicators:
        ema_slow = df['Close'].ewm(span=periods['MACD_slow'], adjust=False).mean()
        ema_fast = df['Close'].ewm(span=periods['MACD_fast'], adjust=False).mean()
        df['MACD'] = ema_fast - ema_slow
        df['Signal Line'] = df['MACD'].ewm(span=periods['MACD_signal'], adjust=False).mean()
    if 'Bollinger Bands' in indicators:
        rolling_mean = df['Close'].rolling(window=periods['Bollinger Bands']).mean()
        rolling_std = df['Close'].rolling(window=periods['Bollinger Bands']).std()
        df['Bollinger High'] = rolling_mean + (rolling_std * 2)
        df['Bollinger Low'] = rolling_mean - (rolling_std * 2)
    if 'Stochastic Oscillator' in indicators:
        low_min = df['Low'].rolling(window=periods['Stochastic']).min()
        high_max = df['High'].rolling(window=periods['Stochastic']).max()
        df['%K'] = (df['Close'] - low_min) * 100 / (high_max - low_min)
        df['%D'] = df['%K'].rolling(window=3).mean()
    df.dropna(inplace=True)
    return df


# Function to compute Relative Strength Index (RSI)
def compute_rsi(series, period=14):
    delta = series.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))


# Function to fetch data
def fetch_data(symbol, start_date, end_date, interval='1d'):
    print("Downloading data...")
    return yf.download(symbol, start=start_date, end=end_date, interval=interval)


# Function to add lag features
def add_lag_features(data, num_lags):
    df = pd.DataFrame(data)
    for lag in range(1, num_lags + 1):
        df[f'lag_{lag}'] = df.iloc[:, 0].shift(lag)
    df.dropna(inplace=True)
    return df


# Function to create sequences
def create_sequences(data, window_size):
    X, y = [], []
    for i in range(window_size, len(data)):
        X.append(data[i - window_size:i])
        y.append(data[i, 0])
    return np.array(X), np.array(y)


# Function to build CNN-LSTM model
def build_cnn_lstm_model(input_shape, num_layers, neurons_per_layer, learning_rate, use_cnn):
    model = Sequential()
    if use_cnn:
        model.add(Conv1D(filters=64, kernel_size=2, activation='relu', input_shape=input_shape))
        model.add(MaxPooling1D(pool_size=2))
        conv_output_shape = input_shape[0] // 2
        lstm_input_shape = (conv_output_shape, 64)
    else:
        lstm_input_shape = input_shape


    for i in range(num_layers):
        if i == 0:
            model.add(LSTM(neurons_per_layer[i], return_sequences=(i < num_layers - 1), input_shape=lstm_input_shape))
        else:
            model.add(LSTM(neurons_per_layer[i], return_sequences=(i < num_layers - 1)))
        model.add(Dropout(0.2))


    model.add(Dense(1))
    model.compile(optimizer=Adam(learning_rate), loss='mean_squared_error')
    return model


# Function to simulate investment
def simulate_investment(predictions, actual_prices, initial_investment, reinvest_percentage, leverage_factor, daily_interest_rate, stop_loss_percentage, min_price_increase_percent):
    cash = initial_investment
    holdings = 0
    buy_price = 0
    trading_history = []


    for day, (predicted_price, actual_price) in enumerate(zip(predictions, actual_prices)):
        predicted_increase = ((predicted_price - actual_price) / actual_price) * 100
        if holdings > 0 and (actual_price - buy_price) / buy_price < -stop_loss_percentage:
            cash = holdings * actual_price
            holdings = 0
            trading_history.append({'Day': day, 'Actual Price': actual_price, 'Predicted Price': predicted_price, 'Action': 'Stop-Loss Sell', 'Holdings': holdings, 'Cash': cash})
            continue


        if predicted_increase >= min_price_increase_percent and cash > 0:
            if leverage_factor > 1:
                cash *= leverage_factor
            holdings = cash / actual_price
            cash = 0
            buy_price = actual_price
            trading_history.append({'Day': day, 'Actual Price': actual_price, 'Predicted Price': predicted_price, 'Action': 'Buy', 'Holdings': holdings, 'Cash': cash})
        elif predicted_price < actual_price and holdings > 0:
            cash = holdings * actual_price
            holdings = 0
            profit = cash - initial_investment
            reinvest_amount = profit * reinvest_percentage
            cash = initial_investment + reinvest_amount
            cash *= (1 + daily_interest_rate)
            trading_history.append({'Day': day, 'Actual Price': actual_price, 'Predicted Price': predicted_price, 'Action': 'Sell', 'Holdings': holdings, 'Cash': cash})


    if holdings > 0:
        cash = holdings * actual_prices[-1]
        trading_history.append({'Day': len(predictions), 'Actual Price': actual_prices[-1], 'Predicted Price': predictions[-1], 'Action': 'Final Sell', 'Holdings': holdings, 'Cash': cash})


    trading_results_df = pd.DataFrame(trading_history)
    return cash, trading_results_df


# Function to confirm date ranges and split
def confirm_date_ranges(start_date, end_date, split_ratio):
    try:
        total_days = (datetime.strptime(end_date, '%Y-%m-%d') - datetime.strptime(start_date, '%Y-%m-%d')).days
        train_days = int(total_days * split_ratio)
        test_days = total_days - train_days


        training_end_date = datetime.strptime(start_date, '%Y-%m-%d') + timedelta(days=train_days)
        testing_start_date = training_end_date + timedelta(days=1)


        training_months = train_days // 30
        testing_months = test_days // 30


        print(f"Training period: {start_date} to {training_end_date.strftime('%Y-%m-%d')} "
              f"({train_days} days, ~{training_months} months)")
        print(f"Testing period: {testing_start_date.strftime('%Y-%m-%d')} to {end_date} "
              f"({test_days} days, ~{testing_months} months)")


        response = input("Confirm if the date ranges are okay (yes/no): ")
        return response.lower() == 'yes', training_end_date.strftime('%Y-%m-%d'), testing_start_date.strftime('%Y-%m-%d')
    except Exception as e:
        print(f"Error in confirming date ranges: {e}")
        return False, None, None


# Function for Bayesian optimization of LSTM model
def bayesian_optimization(X_train, y_train, window_size, input_dim, epochs, learning_rate):
    def lstm_eval(num_layers, neurons_per_layer_1, neurons_per_layer_2, neurons_per_layer_3):
        neurons = [int(neurons_per_layer_1), int(neurons_per_layer_2), int(neurons_per_layer_3)]
        neurons = neurons[:int(num_layers)]  # Select only the required number of layers
        model = Sequential()
        for i, n_neurons in enumerate(neurons):
            model.add(LSTM(n_neurons, return_sequences=(i < len(neurons) - 1), input_shape=(window_size, input_dim)))
            model.add(Dropout(0.2))
        model.add(Dense(1))
        model.compile(optimizer=Adam(learning_rate), loss='mean_squared_error')
        model.fit(X_train, y_train, epochs=epochs, batch_size=32, verbose=0)
        loss = model.evaluate(X_train, y_train, verbose=0)
        return -loss


    pbounds = {
        'num_layers': (1, 3),  # Limit to 3 layers max for this example
        'neurons_per_layer_1': (10, 100),
        'neurons_per_layer_2': (10, 100),
        'neurons_per_layer_3': (10, 100)
    }


    optimizer = BayesianOptimization(f=lstm_eval, pbounds=pbounds, random_state=42)
    optimizer.maximize(init_points=5, n_iter=10)
    optimal_params = optimizer.max['params']
    num_layers = int(optimal_params['num_layers'])
    neurons_per_layer = [int(optimal_params[f'neurons_per_layer_{i+1}']) for i in range(num_layers)]


    print(f"Hyperparameter tuning chose the following structure:")
    print(f"Number of layers: {num_layers}")
    print(f"Neurons per layer: {neurons_per_layer}")


    return num_layers, neurons_per_layer


# Function to build ARIMA model
def build_arima_model(data, order):
    try:
        model = ARIMA(data, order=order)
        model_fit = model.fit()
        return model_fit
    except Exception as e:
        print(f"Error in ARIMA model fitting: {e}")
        return None


# Function to forecast with ARIMA model
def forecast_arima(model_fit, data, start_index, end_index):
    history = list(data[:start_index])
    predictions = []
    try:
        for t in range(start_index, end_index):
            arima_forecast = model_fit.forecast(steps=1)[0]
            predictions.append(arima_forecast)
            history.append(data[t])
            model_fit = ARIMA(history, order=model_fit.model.order).fit()
    except Exception as e:
        print(f"Error in ARIMA forecasting: {e}")
        predictions = np.full((end_index - start_index,), np.nan)
    return np.array(predictions)


# Function to optimize ARIMA parameters
def optimize_arima_params(data):
    model = pm.auto_arima(data, seasonal=True, stepwise=True, suppress_warnings=True)
    return model.order, model.seasonal_order


# Function to display LSTM metrics
def display_lstm_metrics(model, history, X_train, y_train, X_test, y_test):
    test_loss = model.evaluate(X_test, y_test, verbose=0)
    predictions = model.predict(X_test)


    mse = np.mean((predictions.flatten() - y_test) ** 2)
    mae = np.mean(np.abs(predictions.flatten() - y_test))
    y_test_mean = np.mean(y_test)
    ss_tot = np.sum((y_test - y_test_mean) ** 2)
    ss_res = np.sum((y_test - predictions.flatten()) ** 2)
    r_squared = 1 - (ss_res / ss_tot)


    print("\nAdvanced Metrics for LSTM Model:")
    final_training_loss = history.history['loss'][-1] if 'loss' in history.history else 'N/A'
    print(f"Final training loss: {final_training_loss}")
    print(f"LSTM model loss on test set: {test_loss}")
    print(f"MSE: {mse}")
    print(f"MAE: {mae}")
    print(f"R-squared: {r_squared}")


    # Plot the training loss over epochs
    plt.figure(figsize=(10, 5))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.title('LSTM Training Loss Over Epochs')
    plt.xlabel('Epoch')
    plt.ylabel('Loss')
    plt.legend()
    plt.grid(True)
    plt.show()


# Main function
def main():
    # User inputs
    symbol = input("Enter the stock ticker (e.g., 'AAPL'): ")
    start_date = input("Enter start date (YYYY-MM-DD): ")
    end_date = input("Enter end date (YYYY-MM-DD): ")
    interval = input("Enter the data interval (e.g., '1d' for daily): ")


    confirmed = False
    while not confirmed:
        split_ratio = float(input("Enter the train/test split ratio (e.g., 0.8 for 80% training): "))
        confirmed, training_end_date, testing_start_date = confirm_date_ranges(start_date, end_date, split_ratio)


    feature = input("Choose the feature for prediction (Close, Open, Volume): ")
    use_technical_indicators = input("Would you like to add technical indicators as additional features? (yes/no): ").lower() == 'yes'


    technical_indicators = []
    indicator_periods = {}
    default_periods = {
        'SMA': 10,
        'EMA': 10,
        'RSI': 14,
        'MACD_slow': 26,
        'MACD_fast': 12,
        'MACD_signal': 9,
        'Bollinger Bands': 20,
        'Stochastic': 14
    }
    if use_technical_indicators:
        indicators = {
            'SMA': "Simple Moving Average (default 10 days)",
            'EMA': "Exponential Moving Average (default 10 days)",
            'RSI': "Relative Strength Index (default 14 days)",
            'MACD': "Moving Average Convergence Divergence (default 12, 26, 9 days)",
            'Bollinger Bands': "Bollinger Bands (default 20 days)",
            'Stochastic': "Stochastic Oscillator (default 14 days)"
        }
        for key, description in indicators.items():
            include = input(f"Do you want to include {description}? (yes/no): ").lower() == 'yes'
            if include:
                technical_indicators.append(key)
                if key == 'MACD':
                    period = input(f"Enter the periods for MACD slow, fast, and signal (default {default_periods['MACD_slow']}, {default_periods['MACD_fast']}, {default_periods['MACD_signal']}): ")
                    if period:
                        try:
                            slow, fast, signal = map(int, period.split(','))
                            indicator_periods['MACD_slow'] = slow
                            indicator_periods['MACD_fast'] = fast
                            indicator_periods['MACD_signal'] = signal
                        except ValueError:
                            print("Invalid input, using default periods for MACD.")
                            indicator_periods['MACD_slow'] = default_periods['MACD_slow']
                            indicator_periods['MACD_fast'] = default_periods['MACD_fast']
                            indicator_periods['MACD_signal'] = default_periods['MACD_signal']
                    else:
                        indicator_periods['MACD_slow'] = default_periods['MACD_slow']
                        indicator_periods['MACD_fast'] = default_periods['MACD_fast']
                        indicator_periods['MACD_signal'] = default_periods['MACD_signal']
                else:
                    period = input(f"Enter the period for {description} (default {default_periods[key]}): ")
                    if period:
                        try:
                            indicator_periods[key] = int(period)
                        except ValueError:
                            print("Invalid input, using default period.")
                            indicator_periods[key] = default_periods[key]
                    else:
                        indicator_periods[key] = default_periods[key]


    window_size = int(input("Enter the number of days each data point should be trained on (e.g., 60): "))
    num_lags = int(input("Enter the number of lag features to include (e.g., 2): "))
    epochs = int(input("Enter the number of epochs for training the model (e.g., 50): "))
    learning_rate = float(input("Enter the learning rate (e.g., 0.001): "))
    initial_investment = float(input("Enter the amount of money you want to simulate investing (e.g., 1000): "))
    reinvest_percentage = float(input("Enter the percentage of profits to reinvest (default 1 for 100%): ") or 1)
    leverage_factor = float(input("Enter the leverage factor (default 1, e.g., 1.5 for leverage): ") or 1)
    annual_interest_rate = float(input("Enter the annual interest rate for cash reserves (default 0, e.g., 0.02 for 2%): ") or 0)
    daily_interest_rate = annual_interest_rate / 365
    stop_loss_percentage = float(input("Enter the stop loss percentage (e.g., 0.1 for 10%): "))
    min_price_increase_input = input("Enter the minimum price increase percentage for buying (e.g., 10 for 10%, or press Enter for no minimum): ")
    min_price_increase_percent = float(min_price_increase_input) / 100 if min_price_increase_input.strip() else 0


    advanced_metrics = input("Would you like to see advanced metrics? (yes/no): ").lower() == 'yes'
    hyperparameter_tuning = input("Would you like to perform hyperparameter tuning? (yes/no): ").lower() == 'yes'
    ensemble_learning = input("Would you like to use ensemble learning with ARIMA and LSTM models? (yes/no): ").lower() == 'yes'
    use_cnn = input("Would you like to include a CNN layer before the LSTM layers? (yes/no): ").lower() == 'yes'


    data = fetch_data(symbol, start_date, end_date, interval)
    if use_technical_indicators and technical_indicators:
        data = calculate_technical_indicators(data, technical_indicators, indicator_periods)


    data_with_lags = add_lag_features(data[feature], num_lags)
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(data_with_lags)
    X, y = create_sequences(scaled_data, window_size)


    split_point = int(len(X) * split_ratio)
    X_train, X_test = X[:split_point], X[split_point:]
    y_train, y_test = y[:split_point], y[split_point:]


    num_layers = None
    neurons_per_layer = None


    if hyperparameter_tuning:
        num_layers, neurons_per_layer = bayesian_optimization(X_train, y_train, window_size, X.shape[2], epochs, learning_rate)
    else:
        num_layers = int(input("Enter the number of LSTM layers (e.g., 2): "))
        neurons_per_layer = [int(input(f"Enter the number of neurons for layer {i + 1}: ")) for i in range(num_layers)]


    model = build_cnn_lstm_model((window_size, X.shape[2]), num_layers, neurons_per_layer, learning_rate, use_cnn)
    history = model.fit(X_train, y_train, epochs=epochs, batch_size=32, verbose=1)


    predictions_lstm = model.predict(X_test)
    predictions_lstm_expanded = np.zeros((predictions_lstm.shape[0], scaled_data.shape[1]))
    predictions_lstm_expanded[:, 0] = predictions_lstm.flatten()
    predicted_prices_lstm = scaler.inverse_transform(predictions_lstm_expanded)[:, 0]
    actual_prices = scaler.inverse_transform(np.hstack([y_test.reshape(-1, 1), np.zeros((len(y_test), scaled_data.shape[1] - 1))]))[:, 0]


    test_indices = data_with_lags.index[split_point:]  # Get the correct index for the test set


    if ensemble_learning:
        best_order, best_seasonal_order = optimize_arima_params(data[feature].values[:split_point])
        arima_model_fit = build_arima_model(data[feature].values[:split_point], best_order)
        predictions_arima = forecast_arima(arima_model_fit, data[feature].values, split_point, split_point + len(predicted_prices_lstm))


        combined_predictions = []
        for lstm_pred, arima_pred, actual_price in zip(predicted_prices_lstm, predictions_arima, actual_prices):
            if lstm_pred > actual_price and arima_pred > actual_price:
                combined_predictions.append(lstm_pred)
            else:
                combined_predictions.append(actual_price)


        combined_predictions = np.array(combined_predictions)
        final_cash, trading_results_df = simulate_investment(combined_predictions, actual_prices, initial_investment, reinvest_percentage, leverage_factor, daily_interest_rate, stop_loss_percentage, min_price_increase_percent)
    else:
        final_cash, trading_results_df = simulate_investment(predicted_prices_lstm, actual_prices, initial_investment, reinvest_percentage, leverage_factor, daily_interest_rate, stop_loss_percentage, min_price_increase_percent)


    trading_results_df.to_csv('trading_results.csv', index=False)


    plt.figure(figsize=(14, 7))
    plt.plot(test_indices[:len(actual_prices)], actual_prices, label='Actual Prices', color='blue')
    plt.plot(test_indices[:len(predicted_prices_lstm)], predicted_prices_lstm, label='LSTM Predicted Prices', linestyle='--', color='green')
    if ensemble_learning:
        plt.plot(test_indices[:len(predictions_arima)], predictions_arima, label='ARIMA Predicted Prices', linestyle=':', color='orange')
        plt.plot(test_indices[:len(combined_predictions)], combined_predictions, label='Ensemble Predicted Prices', linestyle='-.', color='red')
    plt.title(f'{symbol} Stock Price Prediction on Test Data')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend(loc='upper left')
    plt.grid(True)
    plt.show()


    print(f"Initial investment: ${initial_investment:.2f}")
    print(f"Final cash after trading on test data: ${final_cash:.2f}")


    if hyperparameter_tuning:
        print("\nStructure chosen by hyperparameter tuning:")
        print(f"Number of layers: {num_layers}")
        print(f"Neurons per layer: {neurons_per_layer}")


    if advanced_metrics:
        print("\nAdvanced Metrics for LSTM Model:")
        display_lstm_metrics(model, history, X_train, y_train, X_test, y_test)


        if ensemble_learning:
            print("\nAdvanced Metrics for ARIMA Model:")
            if arima_model_fit is not None:
                print(f"AIC: {arima_model_fit.aic}")
                print(f"BIC: {arima_model_fit.bic}")
                print(f"Log-Likelihood: {arima_model_fit.llf}")
                mse_arima = np.mean((predictions_arima - actual_prices[:len(predictions_arima)]) ** 2)
                mae_arima = np.mean(np.abs(predictions_arima - actual_prices[:len(predictions_arima)]))
                print(f"MSE: {mse_arima}")
                print(f"MAE: {mae_arima}")
            else:
                print("ARIMA model did not produce valid predictions.")


            print("ARIMA Predictions (first 10):", predictions_arima[:10] if predictions_arima is not None else [])
            print("Actual Values (first 10):", actual_prices[:10])


            print("\nPerformance Comparison:")
            lstm_cash, _ = simulate_investment(predicted_prices_lstm, actual_prices, initial_investment, reinvest_percentage, leverage_factor, daily_interest_rate, stop_loss_percentage, min_price_increase_percent)
            arima_cash, _ = simulate_investment(predictions_arima, actual_prices, initial_investment, reinvest_percentage, leverage_factor, daily_interest_rate, stop_loss_percentage, min_price_increase_percent)
            print(f"LSTM model final cash: ${lstm_cash:.2f}")
            print(f"ARIMA model final cash: ${arima_cash:.2f}")


if __name__ == '__main__':
    main()